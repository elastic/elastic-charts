## API Report File for "@elastic/charts"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { $Values } from 'utility-types';
import { ComponentProps } from 'react';
import { ComponentType } from 'react';
import { FC } from 'react';
import { OptionalKeys } from 'utility-types';
import { default as React_2 } from 'react';
import { ReactChild } from 'react';
import { ReactNode } from 'react';
import { RequiredKeys } from 'utility-types';

// Warning: (ae-forgotten-export) The symbol "DatumKey" needs to be exported by the entry point index.d.ts
//
// @public
export type Accessor<D extends BaseDatum = never> = D extends never ? AccessorObjectKey | AccessorArrayIndex : DatumKey<D>;

// @public
export type AccessorArrayIndex = number;

// @public
export type AccessorFn<D extends BaseDatum = any, Return = any> = UnaryAccessorFn<D, Return>;

// @public
export type AccessorObjectKey = string;

// @public
export type AdditiveNumber = number;

// @public (undocumented)
export const AGGREGATE_KEY = "value";

// @public (undocumented)
export function aggregateAccessor(n: ArrayEntry): number;

// @public (undocumented)
export interface AngleFromTo {
    // Warning: (ae-forgotten-export) The symbol "Radian" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    x0: Radian;
    // (undocumented)
    x1: Radian;
}

// @public (undocumented)
export type AnnotationClickListener = (annotations: {
    rects: RectAnnotationEvent[];
    lines: LineAnnotationEvent[];
}) => void;

// @public
export const AnnotationDomainType: Readonly<{
    XDomain: "xDomain";
    YDomain: "yDomain";
}>;

// @public
export type AnnotationDomainType = $Values<typeof AnnotationDomainType>;

// @public (undocumented)
export type AnnotationId = string;

// @public
export type AnnotationPortalSettings = TooltipPortalSettings<'chart'> & {
    customTooltip?: CustomAnnotationTooltip;
    customTooltipDetails?: AnnotationTooltipFormatter;
};

// @public (undocumented)
export type AnnotationSpec<D extends BaseDatum = any> = LineAnnotationSpec<D> | RectAnnotationSpec;

// @public (undocumented)
export type AnnotationTooltipFormatter = (details?: string) => JSX.Element | null;

// @public (undocumented)
export const AnnotationType: Readonly<{
    Line: "line";
    Rectangle: "rectangle";
    Text: "text";
}>;

// @public (undocumented)
export type AnnotationType = $Values<typeof AnnotationType>;

// @public (undocumented)
export interface ArcSeriesStyle {
    // (undocumented)
    arc: ArcStyle;
}

// @public (undocumented)
export interface ArcStyle {
    fill?: Color | ColorVariant;
    opacity: number;
    stroke?: Color | ColorVariant;
    strokeWidth: number;
    visible: boolean;
}

// Warning: (ae-forgotten-export) The symbol "SFProps" needs to be exported by the entry point index.d.ts
//
// @public
export const AreaSeries: <D extends BaseDatum = any>(props: SFProps<AreaSeriesSpec<D>, "chartType" | "specType" | "seriesType", "groupId" | "xScaleType" | "yScaleType" | "hideInLegend" | "histogramModeAlignment", "sortIndex" | "name" | "fit" | "timeZone" | "color" | "curve" | "areaSeriesStyle" | "xNice" | "yNice" | "stackAccessors" | "useDefaultGroupDomain" | "displayValueSettings" | "y0AccessorFormat" | "y1AccessorFormat" | "filterSeriesInTooltip" | "tickFormat" | "y0Accessors" | "splitSeriesAccessors" | "markSizeAccessor" | "markFormat" | "stackMode" | "pointStyleAccessor", "id" | "data" | "xAccessor" | "yAccessors">) => null;

// @public
export type AreaSeriesSpec<D extends BaseDatum = Datum> = BasicSeriesSpec<D, 'area'> & HistogramConfig & Postfixes & {
    seriesType: typeof SeriesType.Area;
    curve?: CurveType;
    areaSeriesStyle?: RecursivePartial<AreaSeriesStyle>;
    stackMode?: StackMode;
    pointStyleAccessor?: PointStyleAccessor;
    fit?: Exclude<Fit, 'explicit'> | FitConfig;
};

// @public (undocumented)
export interface AreaSeriesStyle {
    // (undocumented)
    area: AreaStyle;
    // (undocumented)
    line: LineStyle;
    // (undocumented)
    point: PointStyle;
}

// @public (undocumented)
export interface AreaStyle {
    fill?: Color | ColorVariant;
    opacity: number;
    texture?: TexturedStyles;
    visible: boolean;
}

// @public (undocumented)
export type ArrayEntry = [Key, ArrayNode];

// @public (undocumented)
export interface ArrayNode extends NodeDescriptor {
    // (undocumented)
    [CHILDREN_KEY]: HierarchyOfArrays;
    // (undocumented)
    [PARENT_KEY]: ArrayNode;
    // (undocumented)
    [PATH_KEY]: LegendPath;
    // (undocumented)
    [SORT_INDEX_KEY]: number;
}

// @public
export const Axis: FC<SFProps<AxisSpec, "chartType" | "specType", "position" | "groupId" | "hide" | "showOverlappingTicks" | "showOverlappingLabels", "domain" | "integersOnly" | "style" | "title" | "ticks" | "tickFormat" | "gridLine" | "showGridLines" | "labelFormat" | "showDuplicatedTicks", "id">>;

// @public (undocumented)
export type AxisId = string;

// @public
export interface AxisSpec extends Spec {
    // (undocumented)
    chartType: typeof ChartType.XYAxis;
    domain?: YDomainRange;
    gridLine?: Partial<GridLineStyle>;
    groupId: GroupId;
    hide: boolean;
    id: AxisId;
    integersOnly?: boolean;
    labelFormat?: TickFormatter;
    position: Position;
    showDuplicatedTicks?: boolean;
    // @deprecated
    showGridLines?: boolean;
    showOverlappingLabels: boolean;
    showOverlappingTicks: boolean;
    // (undocumented)
    specType: typeof SpecType.Axis;
    style?: RecursivePartial<Omit<AxisStyle, 'gridLine'>>;
    tickFormat?: TickFormatter;
    ticks?: number;
    title?: string;
}

// @public (undocumented)
export interface AxisStyle {
    // (undocumented)
    axisLine: StrokeStyle & Visible;
    // (undocumented)
    axisPanelTitle: TextStyle & Visible;
    // (undocumented)
    axisTitle: TextStyle & Visible;
    // (undocumented)
    gridLine: {
        horizontal: GridLineStyle;
        vertical: GridLineStyle;
    };
    // (undocumented)
    tickLabel: TextStyle & Visible & {
        rotation: number;
        offset: TextOffset;
        alignment: TextAlignment;
    };
    // (undocumented)
    tickLine: TickStyle;
}

// @public
export interface BackgroundStyle {
    color: string;
}

// @public
export const BandedAccessorType: Readonly<{
    Y0: "y0";
    Y1: "y1";
}>;

// @public (undocumented)
export type BandedAccessorType = $Values<typeof BandedAccessorType>;

// @alpha (undocumented)
export type BandFillColorAccessor = (input: BandFillColorAccessorInput) => Color;

// @alpha (undocumented)
export interface BandFillColorAccessorInput {
    // (undocumented)
    aboveBaseCount: number;
    // (undocumented)
    base: number;
    // (undocumented)
    belowBaseCount: number;
    // (undocumented)
    highestValue: number;
    // (undocumented)
    index: number;
    // (undocumented)
    lowestValue: number;
    // (undocumented)
    target?: number;
    // (undocumented)
    value: number;
}

// @public
export const BarSeries: <D extends BaseDatum = any>(props: SFProps<BarSeriesSpec<D>, "chartType" | "specType" | "seriesType", "groupId" | "xScaleType" | "yScaleType" | "hideInLegend" | "enableHistogramMode", "sortIndex" | "name" | "timeZone" | "color" | "barSeriesStyle" | "xNice" | "yNice" | "stackAccessors" | "useDefaultGroupDomain" | "displayValueSettings" | "y0AccessorFormat" | "y1AccessorFormat" | "filterSeriesInTooltip" | "tickFormat" | "y0Accessors" | "splitSeriesAccessors" | "markSizeAccessor" | "stackMode" | "styleAccessor" | "minBarHeight", "id" | "data" | "xAccessor" | "yAccessors">) => null;

// @public
export type BarSeriesSpec<D extends BaseDatum = Datum> = BasicSeriesSpec<D, 'bar'> & Postfixes & {
    seriesType: typeof SeriesType.Bar;
    enableHistogramMode?: boolean;
    barSeriesStyle?: RecursivePartial<BarSeriesStyle>;
    stackMode?: StackMode;
    styleAccessor?: BarStyleAccessor;
    minBarHeight?: number;
};

// @public (undocumented)
export interface BarSeriesStyle {
    // (undocumented)
    displayValue: DisplayValueStyle;
    // (undocumented)
    rect: RectStyle;
    // (undocumented)
    rectBorder: RectBorderStyle;
}

// @public
export type BarStyleAccessor = (datum: DataSeriesDatum, seriesIdentifier: XYChartSeriesIdentifier) => BarStyleOverride;

// @public (undocumented)
export type BarStyleOverride = RecursivePartial<BarSeriesStyle> | Color | null;

// @public (undocumented)
export interface BaseAnnotationSpec<T extends typeof AnnotationType.Rectangle | typeof AnnotationType.Line, AD extends RectAnnotationDatum | LineAnnotationDatum<D>, S extends RectAnnotationStyle | LineAnnotationStyle, D = never> extends Spec, AnnotationPortalSettings {
    annotationType: T;
    // (undocumented)
    chartType: typeof ChartType.XYAxis;
    dataValues: AD[];
    groupId: GroupId;
    hideTooltips?: boolean;
    // (undocumented)
    specType: typeof SpecType.Annotation;
    style?: Partial<S>;
    zIndex?: number;
}

// @public
export type BaseDatum = Record<string, any> | any[];

// @public (undocumented)
export interface BasePointerEvent {
    // (undocumented)
    chartId: string;
    // (undocumented)
    type: PointerEventType;
}

// @public (undocumented)
export type BasicListener = () => undefined | void;

// Warning: (ae-forgotten-export) The symbol "MarkFormatter" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type BasicSeriesSpec<D extends BaseDatum = Datum, Type extends string = ''> = SeriesSpec<D> & SeriesAccessors<D> & SeriesScales & MarkFormatter<Type>;

// @public
export const BinAgg: Readonly<{
    Sum: "sum";
    None: "none";
}>;

// @public (undocumented)
export type BinAgg = $Values<typeof BinAgg>;

// @public (undocumented)
export const BrushAxis: Readonly<{
    X: "x";
    Y: "y";
    Both: "both";
}>;

// @public (undocumented)
export type BrushAxis = $Values<typeof BrushAxis>;

// @public (undocumented)
export type BrushEndListener = (brushAreaEvent: BrushEvent) => void;

// @public (undocumented)
export type BrushEvent = XYBrushEvent | HeatmapBrushEvent;

// Warning: (ae-incompatible-release-tags) The symbol "BubbleSeries" is marked as @public, but its signature references "BubbleSeriesSpec" which is marked as @alpha
//
// @public
export const BubbleSeries: <D extends BaseDatum = any>(props: SFProps<BubbleSeriesSpec<D>, "chartType" | "specType" | "seriesType", "groupId" | "xScaleType" | "yScaleType" | "hideInLegend", "sortIndex" | "name" | "timeZone" | "color" | "bubbleSeriesStyle" | "xNice" | "yNice" | "stackAccessors" | "useDefaultGroupDomain" | "displayValueSettings" | "y0AccessorFormat" | "y1AccessorFormat" | "filterSeriesInTooltip" | "tickFormat" | "y0Accessors" | "splitSeriesAccessors" | "markSizeAccessor" | "markFormat" | "pointStyleAccessor", "id" | "data" | "xAccessor" | "yAccessors">) => null;

// @alpha
export type BubbleSeriesSpec<D extends BaseDatum = Datum> = BasicSeriesSpec<D, 'bubble'> & {
    seriesType: typeof SeriesType.Bubble;
    bubbleSeriesStyle?: RecursivePartial<BubbleSeriesStyle>;
    pointStyleAccessor?: PointStyleAccessor;
};

// @public (undocumented)
export interface BubbleSeriesStyle {
    // (undocumented)
    point: PointStyle;
}

// @public (undocumented)
export type CategoryKey = string;

// @public (undocumented)
export interface Cell {
    // Warning: (ae-forgotten-export) The symbol "HeatmapCellDatum" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    datum: HeatmapCellDatum;
    // Warning: (ae-forgotten-export) The symbol "Fill" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fill: Fill;
    // (undocumented)
    fontSize: Pixels;
    // (undocumented)
    formatted: string;
    // (undocumented)
    height: number;
    // Warning: (ae-forgotten-export) The symbol "Stroke" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    stroke: Stroke;
    // (undocumented)
    textColor: Color;
    // (undocumented)
    value: number;
    // (undocumented)
    visible: boolean;
    // (undocumented)
    width: number;
    // (undocumented)
    x: number;
    // (undocumented)
    y: number;
    // (undocumented)
    yIndex: number;
}

// Warning: (ae-forgotten-export) The symbol "ChartProps" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "ChartState" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export class Chart extends React_2.Component<ChartProps, ChartState> {
    constructor(props: ChartProps);
    // (undocumented)
    componentDidMount(): void;
    // (undocumented)
    componentWillUnmount(): void;
    // (undocumented)
    static defaultProps: ChartProps;
    // (undocumented)
    dispatchExternalPointerEvent(event: PointerEvent_2): void;
    // (undocumented)
    getChartContainerRef: () => React_2.RefObject<HTMLDivElement>;
    // (undocumented)
    getPNGSnapshot(options?: {
        backgroundColor: string;
        pixelRatio: number;
    }): {
        blobOrDataUrl: any;
        browser: 'IE11' | 'other';
    } | null;
    // (undocumented)
    render(): JSX.Element;
}

// @public (undocumented)
export type ChartSize = number | string | ChartSizeArray | ChartSizeObject;

// @public (undocumented)
export type ChartSizeArray = [number | string | undefined, number | string | undefined];

// @public (undocumented)
export interface ChartSizeObject {
    // (undocumented)
    height?: number | string;
    // (undocumented)
    width?: number | string;
}

// @public
export const ChartType: Readonly<{
    Global: "global";
    Goal: "goal";
    Partition: "partition";
    XYAxis: "xy_axis";
    Heatmap: "heatmap";
    Wordcloud: "wordcloud";
}>;

// @public (undocumented)
export type ChartType = $Values<typeof ChartType>;

// @public (undocumented)
export const CHILDREN_KEY = "children";

// @public (undocumented)
export function childrenAccessor(n: ArrayEntry): HierarchyOfArrays;

// @public
export type Color = string;

// @alpha (undocumented)
export type ColorBand = {
    start: number;
    end: number;
    color: Color;
    label?: string;
};

// @public (undocumented)
export interface ColorConfig {
    // (undocumented)
    defaultVizColor: Color;
    // (undocumented)
    vizColors: Color[];
}

// @public
export const ColorVariant: Readonly<{
    Series: "__use__series__color__";
    None: "__use__empty__color__";
}>;

// @public (undocumented)
export type ColorVariant = $Values<typeof ColorVariant>;

// @public
export type ComponentWithAnnotationDatum<D = any> = ComponentType<LineAnnotationDatum<D>>;

// @public (undocumented)
export type ContinuousDomain = [min: number, max: number];

// @public (undocumented)
export interface CrosshairStyle {
    // (undocumented)
    band: FillStyle & Visible;
    // (undocumented)
    crossLine: StrokeStyle & Visible & Partial<StrokeDashArray>;
    // (undocumented)
    line: StrokeStyle & Visible & Partial<StrokeDashArray>;
}

// @public (undocumented)
export const CurveType: Readonly<{
    CURVE_CARDINAL: 0;
    CURVE_NATURAL: 1;
    CURVE_MONOTONE_X: 2;
    CURVE_MONOTONE_Y: 3;
    CURVE_BASIS: 4;
    CURVE_CATMULL_ROM: 5;
    CURVE_STEP: 6;
    CURVE_STEP_AFTER: 7;
    CURVE_STEP_BEFORE: 8;
    LINEAR: 9;
}>;

// @public (undocumented)
export type CurveType = $Values<typeof CurveType>;

// @public (undocumented)
export type CustomAnnotationTooltip = ComponentType<{
    header?: string;
    details?: string;
    datum: LineAnnotationDatum | RectAnnotationDatum;
}> | null;

// @public
export type CustomTooltip = ComponentType<TooltipInfo>;

// @public (undocumented)
export type CustomXDomain = (DomainRange & Pick<LogScaleOptions, 'logBase'>) | OrdinalDomain;

// @public (undocumented)
export const DARK_THEME: Theme;

// @public (undocumented)
export class DataGenerator {
    // Warning: (ae-forgotten-export) The symbol "RandomNumberGenerator" needs to be exported by the entry point index.d.ts
    constructor(frequency?: number, randomNumberGenerator?: RandomNumberGenerator);
    // (undocumented)
    generateBasicSeries(totalPoints?: number, offset?: number, amplitude?: number): {
        x: number;
        y: number;
    }[];
    // (undocumented)
    generateGroupedSeries(totalPoints?: number, totalGroups?: number, groupPrefix?: string): {
        x: number;
        y: number;
        g: string;
    }[];
    // (undocumented)
    generateRandomGroupedSeries(totalPoints?: number, totalGroups?: number, groupPrefix?: string): {
        x: number;
        y: number;
        z: number;
        g: string;
    }[];
    // (undocumented)
    generateRandomSeries(totalPoints?: number, groupIndex?: number, groupPrefix?: string): {
        x: number;
        y: number;
        z: number;
        g: string;
    }[];
    // (undocumented)
    generateSimpleSeries(totalPoints?: number, groupIndex?: number, groupPrefix?: string): {
        x: number;
        y: number;
        g: string;
    }[];
}

// @public (undocumented)
export type DataName = CategoryKey;

// @public (undocumented)
export interface DataSeriesDatum<T = any> {
    datum: T;
    filled?: FilledValues;
    initialY0: number | null;
    initialY1: number | null;
    mark: number | null;
    x: number | string;
    y0: number | null;
    y1: number | null;
}

// @public (undocumented)
export type Datum = any;

// @public
export interface DebugState {
    // Warning: (ae-forgotten-export) The symbol "DebugStateArea" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    areas?: DebugStateArea[];
    // Warning: (ae-forgotten-export) The symbol "DebugStateAxes" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    axes?: DebugStateAxes;
    // Warning: (ae-forgotten-export) The symbol "DebugStateBar" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    bars?: DebugStateBar[];
    // Warning: (ae-forgotten-export) The symbol "HeatmapDebugState" needs to be exported by the entry point index.d.ts
    heatmap?: HeatmapDebugState;
    // Warning: (ae-forgotten-export) The symbol "DebugStateLegend" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    legend?: DebugStateLegend;
    // Warning: (ae-forgotten-export) The symbol "DebugStateLine" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    lines?: DebugStateLine[];
    // Warning: (ae-forgotten-export) The symbol "PartitionDebugState" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    partition?: PartitionDebugState[];
}

// @public (undocumented)
export const DEFAULT_ANNOTATION_LINE_STYLE: LineAnnotationStyle;

// @public (undocumented)
export const DEFAULT_ANNOTATION_RECT_STYLE: RectAnnotationStyle;

// @public
export const DEFAULT_GLOBAL_ID = "__global__";

// @public (undocumented)
export const DEFAULT_SETTINGS_SPEC: SettingsSpec;

// @public
export const DEFAULT_TOOLTIP_SNAP = true;

// @public
export const DEFAULT_TOOLTIP_TYPE: "vertical";

// @public (undocumented)
export const DEPTH_KEY = "depth";

// @public (undocumented)
export function depthAccessor(n: ArrayEntry): number;

// @public
export const Direction: Readonly<{
    Ascending: "ascending";
    Descending: "descending";
}>;

// @public (undocumented)
export type Direction = $Values<typeof Direction>;

// @public (undocumented)
export interface DisplayValueSpec {
    isAlternatingValueLabel?: boolean;
    // @deprecated
    isValueContainedInElement?: boolean;
    overflowConstraints?: Array<LabelOverflowConstraint>;
    showValueLabel?: boolean;
    valueFormatter?: TickFormatter;
}

// @public (undocumented)
export type DisplayValueStyle = Omit<TextStyle, 'fill' | 'fontSize'> & {
    offsetX: number;
    offsetY: number;
    fontSize: number | {
        min: number;
        max: number;
    };
    fill: Color | {
        color: Color;
        borderColor?: Color;
        borderWidth?: number;
    } | {
        textBorder?: number;
    };
    alignment?: {
        horizontal: Exclude<HorizontalAlignment, 'far' | 'near'>;
        vertical: Exclude<VerticalAlignment, 'far' | 'near'>;
    };
};

// @public
export const DomainPaddingUnit: Readonly<{
    Domain: "domain";
    Pixel: "pixel";
    DomainRatio: "domainRatio";
}>;

// @public
export type DomainPaddingUnit = $Values<typeof DomainPaddingUnit>;

// @public (undocumented)
export interface DomainRange {
    // (undocumented)
    max: number;
    min: number;
    // (undocumented)
    minInterval?: number;
}

// @public (undocumented)
export type ElementClickListener = (elements: Array<XYChartElementEvent | PartitionElementEvent | HeatmapElementEvent | WordCloudElementEvent>) => void;

// @public (undocumented)
export type ElementOverListener = (elements: Array<XYChartElementEvent | PartitionElementEvent | HeatmapElementEvent | WordCloudElementEvent>) => void;

// @public (undocumented)
export const entryKey: ([key]: ArrayEntry) => string;

// @public (undocumented)
export const entryValue: ([, value]: ArrayEntry) => ArrayNode;

// @alpha
export interface ExternalPointerEventsSettings {
    tooltip: TooltipPortalSettings<'chart'> & {
        visible?: boolean;
    };
}

// @public (undocumented)
export interface FilledValues {
    x?: number | string;
    y0?: number;
    y1?: number;
}

// @public (undocumented)
export interface FillStyle {
    fill: Color;
}

// @public (undocumented)
export type FilterPredicate = (series: XYChartSeriesIdentifier) => boolean;

// @public
export const Fit: Readonly<{
    None: "none";
    Carry: "carry";
    Lookahead: "lookahead";
    Nearest: "nearest";
    Average: "average";
    Linear: "linear";
    Zero: "zero";
    Explicit: "explicit";
}>;

// @public (undocumented)
export type Fit = $Values<typeof Fit>;

// @public (undocumented)
export type FitConfig = {
    type: Fit;
    value?: number;
    endValue?: number | 'nearest';
};

// @public (undocumented)
export const FONT_STYLES: readonly ["normal", "italic", "oblique", "inherit", "initial", "unset"];

// @public (undocumented)
export type FontStyle = typeof FONT_STYLES[number];

// @public
export interface GeometryStateStyle {
    opacity: number;
}

// @public
export interface GeometryStyle {
    opacity: number;
}

// @public (undocumented)
export interface GeometryValue {
    // (undocumented)
    accessor: BandedAccessorType;
    datum: any;
    // (undocumented)
    mark: number | null;
    // (undocumented)
    x: any;
    // (undocumented)
    y: any;
}

// @public (undocumented)
export function getNodeName(node: ArrayNode): string;

// @alpha
export const Goal: FC<SFProps<GoalSpec, "chartType" | "specType", "base" | "actual" | "bands" | "ticks" | "bandFillColor" | "tickValueFormatter" | "labelMajor" | "labelMinor" | "centralMajor" | "centralMinor" | "angleStart" | "angleEnd" | "bandLabels", "target" | "config", "id" | "subtype">>;

// @alpha (undocumented)
export type GoalLabelAccessor = LabelAccessor<BandFillColorAccessorInput>;

// Warning: (ae-incompatible-release-tags) The symbol "GoalProps" is marked as @public, but its signature references "Goal" which is marked as @alpha
//
// @public (undocumented)
export type GoalProps = ComponentProps<typeof Goal>;

// @alpha (undocumented)
export interface GoalSpec extends Spec {
    // (undocumented)
    actual: number;
    // (undocumented)
    angleEnd: number;
    // (undocumented)
    angleStart: number;
    // (undocumented)
    bandFillColor: BandFillColorAccessor;
    // (undocumented)
    bandLabels: string[];
    // (undocumented)
    bands: number[];
    // (undocumented)
    base: number;
    // (undocumented)
    centralMajor: string | GoalLabelAccessor;
    // (undocumented)
    centralMinor: string | GoalLabelAccessor;
    // (undocumented)
    chartType: typeof ChartType.Goal;
    // Warning: (ae-forgotten-export) The symbol "Config" needs to be exported by the entry point index.d.ts
    //
    // @deprecated (undocumented)
    config?: RecursivePartial<Config>;
    // (undocumented)
    labelMajor: string | GoalLabelAccessor;
    // (undocumented)
    labelMinor: string | GoalLabelAccessor;
    // (undocumented)
    specType: typeof SpecType.Series;
    // Warning: (ae-forgotten-export) The symbol "GoalSubtype" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    subtype: GoalSubtype;
    // (undocumented)
    target?: number;
    // (undocumented)
    ticks: number[];
    // (undocumented)
    tickValueFormatter: GoalLabelAccessor;
}

// @public (undocumented)
export interface GoalStyles {
    // (undocumented)
    majorCenterLabel: Omit<TextStyle, 'padding' | 'fontSize'>;
    // (undocumented)
    majorLabel: Omit<TextStyle, 'padding' | 'fontSize'>;
    // (undocumented)
    maxFontSize: number;
    // (undocumented)
    minFontSize: number;
    // (undocumented)
    minorCenterLabel: Omit<TextStyle, 'padding' | 'fontSize'>;
    // (undocumented)
    minorLabel: Omit<TextStyle, 'padding' | 'fontSize'>;
    // (undocumented)
    progressLine: Pick<StrokeStyle, 'stroke'>;
    // (undocumented)
    targetLine: Pick<StrokeStyle, 'stroke'>;
    // (undocumented)
    tickLabel: Omit<TextStyle, 'padding' | 'fontSize'>;
    // (undocumented)
    tickLine: Pick<StrokeStyle, 'stroke'>;
}

// @public (undocumented)
export interface GridLineStyle {
    // (undocumented)
    dash: number[];
    // (undocumented)
    opacity: number;
    // (undocumented)
    stroke: Color;
    // (undocumented)
    strokeWidth: number;
    // (undocumented)
    visible: boolean;
}

// @public (undocumented)
export interface GroupBrushExtent {
    // (undocumented)
    extent: [number, number];
    // (undocumented)
    groupId: GroupId;
}

// Warning: (ae-incompatible-release-tags) The symbol "GroupBy" is marked as @public, but its signature references "GroupBySpec" which is marked as @alpha
//
// @public
export const GroupBy: <D extends BaseDatum = any>(props: SFProps<GroupBySpec<D>, "chartType" | "specType", never, "format", "id" | "sort" | "by">) => null;

// @public (undocumented)
export type GroupByAccessor<D extends BaseDatum = any> = (spec: Spec, datum: D) => string | number;

// @public
export type GroupByFormatter<D extends BaseDatum = any> = (value: ReturnType<GroupByAccessor<D>>) => string;

// @public (undocumented)
export type GroupByProps = ComponentProps<typeof GroupBy>;

// Warning: (ae-forgotten-export) The symbol "Predicate" needs to be exported by the entry point index.d.ts
//
// @alpha (undocumented)
export type GroupBySort = Predicate;

// @alpha (undocumented)
export interface GroupBySpec<D extends BaseDatum = any> extends Spec {
    by: GroupByAccessor<D>;
    format?: GroupByFormatter<D>;
    sort: GroupBySort;
}

// @public (undocumented)
export type GroupId = string;

// @alpha
export const Heatmap: <D extends BaseDatum = any>(props: SFProps<HeatmapSpec<D>, "chartType" | "specType", "data" | "config" | "valueAccessor" | "valueFormatter" | "xScaleType" | "xSortPredicate" | "ySortPredicate", "name" | "highlightedData", "id" | "xAccessor" | "yAccessor" | "colorScale">) => null;

// @alpha (undocumented)
export interface HeatmapBandsColorScale {
    // (undocumented)
    bands: Array<ColorBand>;
    labelFormatter?: (start: number, end: number) => string;
    // (undocumented)
    type: 'bands';
}

// @public (undocumented)
export type HeatmapBrushEvent = {
    cells: Cell[];
    x: (string | number)[];
    y: (string | number)[];
};

// @public (undocumented)
export interface HeatmapConfig {
    brushArea: {
        visible: boolean;
        fill: Color;
        stroke: Color;
        strokeWidth: number;
    };
    brushMask: {
        visible: boolean;
        fill: Color;
    };
    brushTool: {
        visible: boolean;
        fill: Color;
    };
    // (undocumented)
    cell: {
        maxWidth: Pixels | 'fill';
        maxHeight: Pixels | 'fill';
        align: 'center';
        label: Font & {
            minFontSize: Pixels;
            maxFontSize: Pixels;
            useGlobalMinFontSize: boolean;
            maxWidth: Pixels | 'fill';
            visible: boolean;
        };
        border: {
            strokeWidth: Pixels;
            stroke: Color;
        };
    };
    // Warning: (ae-forgotten-export) The symbol "FontFamily" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fontFamily: FontFamily;
    // (undocumented)
    grid: {
        cellWidth: {
            min: Pixels;
            max: Pixels | 'fill';
        };
        cellHeight: {
            min: Pixels;
            max: Pixels | 'fill';
        };
        stroke: {
            color: string;
            width: number;
        };
    };
    // (undocumented)
    height: Pixels;
    // (undocumented)
    margin: {
        left: SizeRatio;
        right: SizeRatio;
        top: SizeRatio;
        bottom: SizeRatio;
    };
    // (undocumented)
    maxColumnWidth: Pixels;
    // (undocumented)
    maxLegendHeight?: number;
    // (undocumented)
    maxRowHeight: Pixels;
    // (undocumented)
    timeZone: string;
    // (undocumented)
    width: Pixels;
    // Warning: (ae-forgotten-export) The symbol "Font" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    xAxisLabel: Font & {
        name: string;
        fontSize: Pixels;
        width: Pixels | 'auto';
        align: TextAlign;
        baseline: TextBaseline;
        visible: boolean;
        padding: number;
        formatter: (value: string | number) => string;
    };
    // (undocumented)
    yAxisLabel: Font & {
        name: string;
        fontSize: Pixels;
        width: Pixels | 'auto' | {
            max: Pixels;
        };
        baseline: TextBaseline;
        visible: boolean;
        padding: number | {
            left?: number;
            right?: number;
            top?: number;
            bottom?: number;
        };
        formatter: (value: string | number) => string;
    };
}

// @public (undocumented)
export type HeatmapElementEvent = [Cell, SeriesIdentifier];

// @alpha (undocumented)
export interface HeatmapSpec<D extends BaseDatum = Datum> extends Spec {
    // (undocumented)
    chartType: typeof ChartType.Heatmap;
    // (undocumented)
    colorScale: HeatmapBandsColorScale;
    // (undocumented)
    config: RecursivePartial<HeatmapConfig>;
    // (undocumented)
    data: D[];
    // (undocumented)
    highlightedData?: {
        x: Array<string | number>;
        y: Array<string | number>;
    };
    // (undocumented)
    name?: string;
    // (undocumented)
    specType: typeof SpecType.Series;
    // (undocumented)
    valueAccessor: Accessor | AccessorFn;
    // (undocumented)
    valueFormatter: (value: number) => string;
    // (undocumented)
    xAccessor: Accessor<D> | AccessorFn<D>;
    // (undocumented)
    xScaleType: SeriesScales['xScaleType'];
    // (undocumented)
    xSortPredicate: Predicate;
    // (undocumented)
    yAccessor: Accessor<D> | AccessorFn<D>;
    // (undocumented)
    ySortPredicate: Predicate;
}

// @public
export const HIERARCHY_ROOT_KEY: Key;

// @public (undocumented)
export type HierarchyOfArrays = Array<ArrayEntry>;

// @public
export const HistogramBarSeries: <D extends BaseDatum = any>(props: SFProps<HistogramBarSeriesSpec<D>, "chartType" | "specType" | "seriesType", "groupId" | "xScaleType" | "yScaleType" | "hideInLegend" | "enableHistogramMode", "sortIndex" | "name" | "timeZone" | "color" | "barSeriesStyle" | "xNice" | "yNice" | "useDefaultGroupDomain" | "displayValueSettings" | "y0AccessorFormat" | "y1AccessorFormat" | "filterSeriesInTooltip" | "tickFormat" | "y0Accessors" | "splitSeriesAccessors" | "markSizeAccessor" | "stackMode" | "styleAccessor" | "minBarHeight", "id" | "data" | "xAccessor" | "yAccessors">) => null;

// @public
export type HistogramBarSeriesSpec<D extends BaseDatum = Datum> = Omit<BarSeriesSpec<D>, 'stackAccessors'> & {
    enableHistogramMode: true;
};

// @public (undocumented)
export interface HistogramConfig {
    histogramModeAlignment?: HistogramModeAlignment;
}

// @public (undocumented)
export type HistogramModeAlignment = 'start' | 'center' | 'end';

// @public (undocumented)
export const HistogramModeAlignments: Readonly<{
    Start: HistogramModeAlignment;
    Center: HistogramModeAlignment;
    End: HistogramModeAlignment;
}>;

// @public (undocumented)
export const HorizontalAlignment: Readonly<{
    Center: "center";
    Right: "right";
    Left: "left";
    Near: "near";
    Far: "far";
}>;

// @public
export type HorizontalAlignment = $Values<typeof HorizontalAlignment>;

// Warning: (ae-forgotten-export) The symbol "BinaryAccessorFn" needs to be exported by the entry point index.d.ts
//
// @public
export type IndexedAccessorFn<D extends BaseDatum = any, Return = any> = UnaryAccessorFn<D, Return> | BinaryAccessorFn<D, Return>;

// @public (undocumented)
export const INPUT_KEY = "inputIndex";

// @public
export type IsAny<T, True, False = never> = True | False extends (T extends never ? True : False) ? True : False;

// @public
export type IsUnknown<T, True, False = never> = unknown extends T ? IsAny<T, False, True> : False;

// @public (undocumented)
export type Key = CategoryKey;

// @public (undocumented)
export type LabelAccessor<T = PrimitiveValue> = (value: T) => string;

// @public (undocumented)
export const LabelOverflowConstraint: Readonly<{
    BarGeometry: "barGeometry";
    ChartEdges: "chartEdges";
}>;

// @public (undocumented)
export type LabelOverflowConstraint = $Values<typeof LabelOverflowConstraint>;

// @public (undocumented)
export interface LayerValue {
    depth: number;
    groupByRollup: PrimitiveValue;
    path: LegendPath;
    smAccessorValue: ReturnType<GroupByAccessor>;
    sortIndex: number;
    value: number;
}

// @public (undocumented)
export const LayoutDirection: Readonly<{
    Horizontal: "horizontal";
    Vertical: "vertical";
}>;

// @public (undocumented)
export type LayoutDirection = $Values<typeof LayoutDirection>;

// @public
export type LegendAction = ComponentType<LegendActionProps>;

// @public
export interface LegendActionProps {
    color: string;
    label: string;
    series: SeriesIdentifier[];
}

// @public (undocumented)
export type LegendColorPicker = ComponentType<LegendColorPickerProps>;

// @public (undocumented)
export interface LegendColorPickerProps {
    anchor: HTMLElement;
    color: Color;
    onChange: (color: Color | null) => void;
    onClose: () => void;
    seriesIdentifiers: SeriesIdentifier[];
}

// @public (undocumented)
export type LegendItemListener = (series: SeriesIdentifier[]) => void;

// @public (undocumented)
export interface LegendLabelOptions {
    maxLines: number;
}

// @public
export type LegendPath = LegendPathElement[];

// @public (undocumented)
export type LegendPathElement = {
    index: number;
    value: CategoryKey;
};

// @public
export type LegendPositionConfig = {
    vAlign: typeof VerticalAlignment.Top | typeof VerticalAlignment.Bottom;
    hAlign: typeof HorizontalAlignment.Left | typeof HorizontalAlignment.Right;
    direction: LayoutDirection;
    floating: boolean;
    floatingColumns?: number;
};

// @public
export interface LegendSpec {
    flatLegend?: boolean;
    legendAction?: LegendAction;
    // (undocumented)
    legendColorPicker?: LegendColorPicker;
    legendMaxDepth: number;
    legendPosition: Position | LegendPositionConfig;
    legendStrategy?: LegendStrategy;
    // (undocumented)
    onLegendItemClick?: LegendItemListener;
    // (undocumented)
    onLegendItemMinusClick?: LegendItemListener;
    // (undocumented)
    onLegendItemOut?: BasicListener;
    // (undocumented)
    onLegendItemOver?: LegendItemListener;
    // (undocumented)
    onLegendItemPlusClick?: LegendItemListener;
    showLegend: boolean;
    showLegendExtra: boolean;
}

// @public (undocumented)
export const LegendStrategy: Readonly<{
    Node: "node";
    Path: "path";
    KeyInLayer: "keyInLayer";
    Key: "key";
    NodeWithDescendants: "nodeWithDescendants";
    PathWithDescendants: "pathWithDescendants";
}>;

// @public (undocumented)
export type LegendStrategy = $Values<typeof LegendStrategy>;

// @public (undocumented)
export interface LegendStyle {
    horizontalHeight: number;
    labelOptions: LegendLabelOptions;
    margin: number;
    spacingBuffer: number;
    verticalWidth: number;
}

// @public (undocumented)
export const LIGHT_THEME: Theme;

// @public
export const LineAnnotation: <D = any>(props: SFProps<LineAnnotationSpec<D>, "chartType" | "specType", "style" | "zIndex" | "groupId" | "hideLines" | "hideLinesTooltips" | "annotationType" | "hideTooltips", "offset" | "fallbackPlacements" | "placement" | "boundary" | "boundaryPadding" | "marker" | "customTooltip" | "markerBody" | "markerDimensions" | "markerPosition" | "customTooltipDetails", "id" | "dataValues" | "domainType">) => null;

// @public
export interface LineAnnotationDatum<D = any> {
    dataValue: D;
    details?: string;
    header?: string;
}

// @public (undocumented)
export type LineAnnotationEvent = {
    id: SpecId;
    datum: LineAnnotationDatum<any>;
};

// @public (undocumented)
export type LineAnnotationSpec<D = any> = BaseAnnotationSpec<typeof AnnotationType.Line, LineAnnotationDatum<D>, LineAnnotationStyle, D> & {
    domainType: AnnotationDomainType;
    marker?: ReactNode | ComponentWithAnnotationDatum<D>;
    markerBody?: ReactNode | ComponentWithAnnotationDatum<D>;
    markerDimensions?: {
        width: number;
        height: number;
    };
    markerPosition?: Position;
    hideLines?: boolean;
    hideLinesTooltips?: boolean;
    zIndex?: number;
};

// @public
export interface LineAnnotationStyle {
    // @deprecated
    details: TextStyle;
    line: StrokeStyle & Opacity & Partial<StrokeDashArray>;
}

// @public
export const LineSeries: <D extends BaseDatum = any>(props: SFProps<LineSeriesSpec<D>, "chartType" | "specType" | "seriesType", "groupId" | "xScaleType" | "yScaleType" | "hideInLegend" | "histogramModeAlignment", "sortIndex" | "name" | "fit" | "timeZone" | "color" | "curve" | "lineSeriesStyle" | "xNice" | "yNice" | "stackAccessors" | "useDefaultGroupDomain" | "displayValueSettings" | "y0AccessorFormat" | "y1AccessorFormat" | "filterSeriesInTooltip" | "tickFormat" | "y0Accessors" | "splitSeriesAccessors" | "markSizeAccessor" | "markFormat" | "pointStyleAccessor", "id" | "data" | "xAccessor" | "yAccessors">) => null;

// @public
export type LineSeriesSpec<D extends BaseDatum = Datum> = BasicSeriesSpec<D, 'line'> & HistogramConfig & {
    seriesType: typeof SeriesType.Line;
    curve?: CurveType;
    lineSeriesStyle?: RecursivePartial<LineSeriesStyle>;
    pointStyleAccessor?: PointStyleAccessor;
    fit?: Exclude<Fit, 'explicit'> | FitConfig;
};

// @public (undocumented)
export interface LineSeriesStyle {
    // (undocumented)
    line: LineStyle;
    // (undocumented)
    point: PointStyle;
}

// @public (undocumented)
export interface LineStyle {
    dash?: number[];
    opacity: number;
    stroke?: Color | ColorVariant;
    strokeWidth: number;
    visible: boolean;
}

// @public
export interface LogScaleOptions {
    logBase?: number;
    logMinLimit?: number;
}

// @public
export type Margins = PerSideDistance;

// @public
export type MarkBuffer = number | ((radius: number) => number);

// @public (undocumented)
export function mergeWithDefaultAnnotationLine(config?: Partial<LineAnnotationStyle>): LineAnnotationStyle;

// @public (undocumented)
export function mergeWithDefaultAnnotationRect(config?: Partial<RectAnnotationStyle>): RectAnnotationStyle;

// @public
export function mergeWithDefaultTheme(theme: PartialTheme, defaultTheme?: Theme, auxiliaryThemes?: PartialTheme[]): Theme;

// @public (undocumented)
export const MODEL_KEY = "parent";

// @public (undocumented)
export function niceTimeFormatByDay(days: number): "YYYY-MM-DD" | "MMMM DD" | "MM-DD HH:mm" | "HH:mm:ss";

// @public (undocumented)
export function niceTimeFormatter(domain: [number, number]): TickFormatter;

// @public (undocumented)
export type NodeColorAccessor = (d: ShapeTreeNode, index: number, array: HierarchyOfArrays) => string;

// @public (undocumented)
export interface NodeDescriptor {
    // (undocumented)
    [DEPTH_KEY]: number;
    // (undocumented)
    [INPUT_KEY]?: Array<number>;
    // (undocumented)
    [STATISTICS_KEY]: Statistics;
    // (undocumented)
    [AGGREGATE_KEY]: number;
}

// @public
export type NodeSorter = (a: ArrayEntry, b: ArrayEntry) => number;

// @public (undocumented)
export type NonAny = number | boolean | string | symbol | null;

// @public
export const NULL_SMALL_MULTIPLES_KEY: Key;

// @public (undocumented)
export interface Opacity {
    opacity: number;
}

// @public
export interface OrderBy {
    // (undocumented)
    binAgg?: BinAgg;
    // (undocumented)
    direction?: Direction;
}

// @public (undocumented)
export type OrdinalDomain = (number | string)[];

// @public (undocumented)
export type OutOfRoomCallback = (wordCount: number, renderedWordCount: number, renderedWords: string[]) => void;

// @public (undocumented)
export type Padding = PerSideDistance;

// @public (undocumented)
export const PARENT_KEY = "parent";

// @public (undocumented)
export function parentAccessor(n: ArrayEntry): ArrayNode;

// @public (undocumented)
export type PartialTheme = RecursivePartial<Theme>;

// Warning: (ae-forgotten-export) The symbol "PartitionSpec" needs to be exported by the entry point index.d.ts
//
// @public
export const Partition: <D extends BaseDatum = any>(props: SFProps<PartitionSpec<D>, "chartType" | "specType", "config" | "valueAccessor" | "valueFormatter" | "valueGetter" | "percentFormatter" | "topGroove" | "smallMultiples" | "layers", never, "id" | "data">) => null;

// Warning: (ae-forgotten-export) The symbol "StaticConfig" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface PartitionConfig extends StaticConfig {
    // @alpha (undocumented)
    animation: {
        duration: TimeMs;
        keyframes: Array<AnimKeyframe>;
    };
}

// @public (undocumented)
export type PartitionElementEvent = [Array<LayerValue>, SeriesIdentifier];

// Warning: (ae-forgotten-export) The symbol "LabelConfig" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export interface PartitionFillLabel extends LabelConfig {
    // (undocumented)
    clipText: boolean;
}

// @public
export interface PartitionLayer<D extends BaseDatum = Datum> {
    // Warning: (ae-forgotten-export) The symbol "ExtendedFillLabelConfig" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    fillLabel?: Partial<ExtendedFillLabelConfig>;
    // (undocumented)
    groupByRollup: IndexedAccessorFn<D>;
    // (undocumented)
    nodeLabel?: LabelAccessor;
    // (undocumented)
    shape?: {
        fillColor: string | NodeColorAccessor;
    };
    // (undocumented)
    showAccessor?: ShowAccessor;
    // (undocumented)
    sortPredicate?: NodeSorter | null;
}

// @public (undocumented)
export const PartitionLayout: Readonly<{
    sunburst: "sunburst";
    treemap: "treemap";
    icicle: "icicle";
    flame: "flame";
    mosaic: "mosaic";
    waffle: "waffle";
}>;

// @public (undocumented)
export type PartitionLayout = $Values<typeof PartitionLayout>;

// @public (undocumented)
export const PATH_KEY = "path";

// @public (undocumented)
export function pathAccessor(n: ArrayEntry): LegendPath;

// @public
export interface PerSideDistance {
    // (undocumented)
    bottom: number;
    // (undocumented)
    left: number;
    // (undocumented)
    right: number;
    // (undocumented)
    top: number;
}

// @public (undocumented)
export type Pixels = number;

// @public
export const Placement: Readonly<{
    Top: "top";
    Bottom: "bottom";
    Left: "left";
    Right: "right";
    TopStart: "top-start";
    TopEnd: "top-end";
    BottomStart: "bottom-start";
    BottomEnd: "bottom-end";
    RightStart: "right-start";
    RightEnd: "right-end";
    LeftStart: "left-start";
    LeftEnd: "left-end";
    Auto: "auto";
    AutoStart: "auto-start";
    AutoEnd: "auto-end";
}>;

// @public
export type Placement = $Values<typeof Placement>;

// @public (undocumented)
type PointerEvent_2 = PointerOverEvent | PointerOutEvent;
export { PointerEvent_2 as PointerEvent }

// @public (undocumented)
export const PointerEventType: Readonly<{
    Over: "Over";
    Out: "Out";
}>;

// @public (undocumented)
export type PointerEventType = $Values<typeof PointerEventType>;

// @public (undocumented)
export interface PointerOutEvent extends BasePointerEvent {
    // (undocumented)
    type: typeof PointerEventType.Out;
}

// @public
export interface PointerOverEvent extends BasePointerEvent, ProjectedValues {
    // (undocumented)
    scale: ScaleContinuousType | ScaleOrdinalType;
    // (undocumented)
    type: typeof PointerEventType.Over;
    // @alpha
    unit?: string;
}

// @public
export type PointerUpdateListener = (event: PointerEvent_2) => void;

// @public
export const PointerUpdateTrigger: Readonly<{
    X: "x";
    Y: "y";
    Both: "both";
}>;

// @public (undocumented)
export type PointerUpdateTrigger = $Values<typeof PointerUpdateTrigger>;

// @public (undocumented)
export const PointShape: Readonly<{
    Circle: "circle";
    Square: "square";
    Diamond: "diamond";
    Plus: "plus";
    X: "x";
    Triangle: "triangle";
}>;

// @public (undocumented)
export type PointShape = $Values<typeof PointShape>;

// @public (undocumented)
export interface PointStyle {
    fill?: Color | ColorVariant;
    opacity: number;
    radius: number;
    shape?: PointShape;
    stroke?: Color | ColorVariant;
    strokeWidth: number;
    visible: boolean;
}

// @public
export type PointStyleAccessor = (datum: DataSeriesDatum, seriesIdentifier: XYChartSeriesIdentifier) => PointStyleOverride;

// @public (undocumented)
export type PointStyleOverride = RecursivePartial<PointStyle> | Color | null;

// @public (undocumented)
export const Position: Readonly<{
    Top: "top";
    Bottom: "bottom";
    Left: "left";
    Right: "right";
}>;

// @public (undocumented)
export type Position = $Values<typeof Position>;

// @public (undocumented)
export interface Postfixes {
    y0AccessorFormat?: string;
    y1AccessorFormat?: string;
}

// @public
export type PrimitiveValue = string | number | null;

// @public
export type ProjectedValues = {
    x: PrimitiveValue;
    y: Array<{
        value: PrimitiveValue;
        groupId: string;
    }>;
    smVerticalValue: PrimitiveValue;
    smHorizontalValue: PrimitiveValue;
};

// @public
export type ProjectionClickListener = (values: ProjectedValues) => void;

// @public
export type Ratio = number;

// @public (undocumented)
export type RawTextGetter = (node: ShapeTreeNode) => string;

// @public (undocumented)
export const RectAnnotation: FC<SFProps<RectAnnotationSpec, "chartType" | "specType", "style" | "zIndex" | "groupId" | "outside" | "annotationType", "offset" | "fallbackPlacements" | "placement" | "boundary" | "boundaryPadding" | "customTooltip" | "customTooltipDetails" | "hideTooltips" | "renderTooltip" | "outsideDimension", "id" | "dataValues">>;

// @public
export interface RectAnnotationDatum {
    coordinates: {
        x0?: PrimitiveValue;
        x1?: PrimitiveValue;
        y0?: PrimitiveValue;
        y1?: PrimitiveValue;
    };
    details?: string;
}

// @public (undocumented)
export type RectAnnotationEvent = {
    id: SpecId;
    datum: RectAnnotationDatum;
};

// @public (undocumented)
export type RectAnnotationSpec = BaseAnnotationSpec<typeof AnnotationType.Rectangle, RectAnnotationDatum, RectAnnotationStyle> & {
    renderTooltip?: AnnotationTooltipFormatter;
    zIndex?: number;
    outside?: boolean;
    outsideDimension?: number;
};

// @public (undocumented)
export type RectAnnotationStyle = StrokeStyle & FillStyle & Opacity & Partial<StrokeDashArray>;

// @public (undocumented)
export interface RectBorderStyle {
    stroke?: Color | ColorVariant;
    strokeOpacity?: number;
    strokeWidth: number;
    visible: boolean;
}

// @public (undocumented)
export interface RectStyle {
    fill?: Color | ColorVariant;
    opacity: number;
    texture?: TexturedStyles;
    widthPixel?: Pixels;
    widthRatio?: Ratio;
}

// @public
export type RecursivePartial<T> = {
    [P in keyof T]?: T[P] extends NonAny[] ? T[P] : T[P] extends ReadonlyArray<NonAny> ? T[P] : T[P] extends (infer U)[] ? RecursivePartial<U>[] : T[P] extends ReadonlyArray<infer U> ? ReadonlyArray<RecursivePartial<U>> : T[P] extends Set<infer V> ? Set<RecursivePartial<V>> : T[P] extends Map<infer K, infer V> ? Map<K, RecursivePartial<V>> : T[P] extends NonAny ? T[P] : IsUnknown<T[P], 1, 0> extends 1 ? T[P] : RecursivePartial<T[P]>;
};

// @alpha
export type RelativeBandsPadding = {
    outer: Ratio;
    inner: Ratio;
};

// @public
export type RenderChangeListener = (isRendered: boolean) => void;

// @public (undocumented)
export type Rendering = 'canvas' | 'svg';

// @public (undocumented)
export type Rotation = 0 | 90 | -90 | 180;

// @public (undocumented)
export type ScaleBandType = ScaleOrdinalType;

// @public (undocumented)
export type ScaleContinuousType = typeof ScaleType.LinearBinary | typeof ScaleType.Linear | typeof ScaleType.Time | typeof ScaleType.Log | typeof ScaleType.Sqrt;

// @public (undocumented)
export type ScaleOrdinalType = typeof ScaleType.Ordinal;

// @public (undocumented)
export interface ScalesConfig {
    barsPadding: number;
    histogramPadding: number;
}

// @public
export const ScaleType: Readonly<{
    LinearBinary: "linear_binary";
    Linear: "linear";
    Ordinal: "ordinal";
    Log: "log";
    Sqrt: "sqrt";
    Time: "time";
    Quantize: "quantize";
    Quantile: "quantile";
    Threshold: "threshold";
}>;

// @public
export type ScaleType = $Values<typeof ScaleType>;

// @public (undocumented)
export interface SectorGeomSpecY {
    // Warning: (ae-forgotten-export) The symbol "Distance" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    y0px: Distance;
    // (undocumented)
    y1px: Distance;
}

// @public (undocumented)
export interface SeriesAccessors<D extends BaseDatum = any> {
    markSizeAccessor?: Accessor<D> | AccessorFn<D>;
    splitSeriesAccessors?: (Accessor<D> | AccessorFn<D>)[];
    stackAccessors?: (Accessor<any> | AccessorFn<any>)[];
    xAccessor: Accessor<D> | AccessorFn<D>;
    y0Accessors?: (Accessor<D> | AccessorFn<D>)[];
    yAccessors: (Accessor<D> | AccessorFn<D>)[];
}

// @public (undocumented)
export type SeriesColorAccessor = string | SeriesColorsArray | SeriesColorAccessorFn;

// @public (undocumented)
export type SeriesColorAccessorFn = (seriesIdentifier: XYChartSeriesIdentifier) => string | null;

// @public (undocumented)
export type SeriesColorsArray = string[];

// @public
export type SeriesIdentifier = {
    specId: SpecId;
    key: SeriesKey;
};

// @public
export type SeriesKey = CategoryKey;

// @public (undocumented)
export type SeriesName = string | number | null;

// @public (undocumented)
export type SeriesNameAccessor = string | SeriesNameFn | SeriesNameConfigOptions;

// @public
export interface SeriesNameConfig {
    accessor: string | number;
    name?: string | number;
    sortIndex?: number;
    value?: string | number;
}

// @public (undocumented)
export interface SeriesNameConfigOptions {
    delimiter?: string;
    names?: SeriesNameConfig[];
}

// @public
export type SeriesNameFn = (series: XYChartSeriesIdentifier, isTooltip: boolean) => SeriesName;

// @public (undocumented)
export interface SeriesScales {
    timeZone?: string;
    xNice?: boolean;
    xScaleType: XScaleType;
    yNice?: boolean;
    yScaleType: ScaleContinuousType;
}

// @public (undocumented)
export interface SeriesSpec<D extends BaseDatum = Datum> extends Spec {
    // (undocumented)
    chartType: typeof ChartType.XYAxis;
    color?: SeriesColorAccessor;
    data: D[];
    // (undocumented)
    displayValueSettings?: DisplayValueSpec;
    filterSeriesInTooltip?: FilterPredicate;
    groupId: string;
    hideInLegend?: boolean;
    name?: SeriesNameAccessor;
    seriesType: SeriesType;
    // @deprecated
    sortIndex?: number;
    // (undocumented)
    specType: typeof SpecType.Series;
    tickFormat?: TickFormatter;
    useDefaultGroupDomain?: boolean | string;
    // Warning: (ae-forgotten-export) The symbol "AccessorFormat" needs to be exported by the entry point index.d.ts
    y0AccessorFormat?: AccessorFormat;
    y1AccessorFormat?: AccessorFormat;
}

// @public (undocumented)
export type SeriesSpecs<D extends BaseDatum = Datum, S extends BasicSeriesSpec<D> = BasicSeriesSpec<D>> = Array<S>;

// @public (undocumented)
export const SeriesType: Readonly<{
    Area: "area";
    Bar: "bar";
    Line: "line";
    Bubble: "bubble";
}>;

// @public
export type SeriesType = $Values<typeof SeriesType>;

// @public
export const Settings: (props: SFProps<SettingsSpec, keyof typeof settingsBuildProps['overrides'], keyof typeof settingsBuildProps['defaults'], keyof typeof settingsBuildProps['optionals'], keyof typeof settingsBuildProps['requires']>) => null;

// Warning: (ae-forgotten-export) The symbol "BuildProps" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const settingsBuildProps: BuildProps<SettingsSpec, "id" | "chartType" | "specType", "rotation" | "debug" | "tooltip" | "ariaLabelHeadingLevel" | "ariaUseDefaultSummary" | "legendPosition" | "legendMaxDepth" | "showLegend" | "showLegendExtra" | "baseTheme" | "rendering" | "animateData" | "externalPointerEvents" | "resizeDebounce" | "pointerUpdateTrigger" | "brushAxis" | "minBrushDelta" | "allowBrushingLastHistogramBin", "ariaLabel" | "ariaDescription" | "ariaDescribedBy" | "ariaLabelledBy" | "ariaTableCaption" | "flatLegend" | "legendAction" | "legendColorPicker" | "legendStrategy" | "onLegendItemClick" | "onLegendItemMinusClick" | "onLegendItemOut" | "onLegendItemOver" | "onLegendItemPlusClick" | "xDomain" | "orderOrdinalBinsBy" | "theme" | "debugState" | "onProjectionClick" | "onElementClick" | "onElementOver" | "onElementOut" | "pointBuffer" | "onBrushEnd" | "onPointerUpdate" | "onRenderChange" | "onAnnotationClick" | "pointerUpdateDebounce" | "roundHistogramBrushValues" | "noResults", never>;

// @public (undocumented)
export type SettingsProps = ComponentProps<typeof Settings>;

// @public
export interface SettingsSpec extends Spec, LegendSpec {
    allowBrushingLastHistogramBin: boolean;
    // (undocumented)
    animateData: boolean;
    ariaDescribedBy?: string;
    ariaDescription?: string;
    ariaLabel?: string;
    ariaLabelHeadingLevel: 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6' | 'p';
    ariaLabelledBy?: string;
    ariaTableCaption?: string;
    ariaUseDefaultSummary: boolean;
    baseTheme?: Theme;
    brushAxis?: BrushAxis;
    debug: boolean;
    // @alpha
    debugState?: boolean;
    // @alpha
    externalPointerEvents: ExternalPointerEventsSettings;
    minBrushDelta?: number;
    noResults?: ComponentType | ReactChild;
    onAnnotationClick?: AnnotationClickListener;
    // (undocumented)
    onBrushEnd?: BrushEndListener;
    // (undocumented)
    onElementClick?: ElementClickListener;
    // (undocumented)
    onElementOut?: BasicListener;
    // (undocumented)
    onElementOver?: ElementOverListener;
    // (undocumented)
    onPointerUpdate?: PointerUpdateListener;
    onProjectionClick?: ProjectionClickListener;
    // (undocumented)
    onRenderChange?: RenderChangeListener;
    orderOrdinalBinsBy?: OrderBy;
    // (undocumented)
    pointBuffer?: MarkBuffer;
    pointerUpdateDebounce?: number;
    pointerUpdateTrigger: PointerUpdateTrigger;
    // (undocumented)
    rendering: Rendering;
    resizeDebounce?: number;
    // (undocumented)
    rotation: Rotation;
    roundHistogramBrushValues?: boolean;
    theme?: PartialTheme | PartialTheme[];
    tooltip: TooltipSettings;
    // (undocumented)
    xDomain?: CustomXDomain;
}

// @public (undocumented)
export interface ShapeTreeNode extends TreeNode, SectorGeomSpecY {
    // (undocumented)
    dataName: DataName;
    // (undocumented)
    depth: number;
    // (undocumented)
    [MODEL_KEY]: ArrayNode;
    // (undocumented)
    path: LegendPath;
    // (undocumented)
    sortIndex: number;
    // (undocumented)
    value: number;
    // (undocumented)
    yMidPx: Distance;
}

// @public (undocumented)
export interface SharedGeometryStateStyle {
    // (undocumented)
    default: GeometryStateStyle;
    // (undocumented)
    highlighted: GeometryStateStyle;
    // (undocumented)
    unhighlighted: GeometryStateStyle;
}

// @public (undocumented)
export type ShowAccessor = (value: PrimitiveValue) => boolean;

// @public
export interface SimplePadding {
    // (undocumented)
    inner: number;
    // (undocumented)
    outer: number;
}

// @alpha
export const SmallMultiples: FC<SFProps<SmallMultiplesSpec, "id" | "chartType" | "specType", never, "style" | "splitHorizontally" | "splitVertically" | "splitZigzag", never>>;

// Warning: (ae-incompatible-release-tags) The symbol "SmallMultiplesProps" is marked as @public, but its signature references "SmallMultiples" which is marked as @alpha
//
// @public (undocumented)
export type SmallMultiplesProps = ComponentProps<typeof SmallMultiples>;

// @alpha (undocumented)
export interface SmallMultiplesSpec extends Spec {
    splitHorizontally?: string;
    splitVertically?: string;
    splitZigzag?: string;
    style?: Partial<SmallMultiplesStyle>;
}

// @alpha
export interface SmallMultiplesStyle {
    horizontalPanelPadding: RelativeBandsPadding;
    verticalPanelPadding: RelativeBandsPadding;
}

// @public (undocumented)
export const SORT_INDEX_KEY = "sortIndex";

// @public (undocumented)
export type Sorter = (a: number, b: number) => number;

// @public (undocumented)
export function sortIndexAccessor(n: ArrayEntry): number;

// @public
export interface SortSeriesByConfig {
    default?: SeriesCompareFn;
    // Warning: (ae-forgotten-export) The symbol "SeriesCompareFn" needs to be exported by the entry point index.d.ts
    legend?: SeriesCompareFn;
    rendering?: SeriesCompareFn;
    tooltip?: SeriesCompareFn;
}

// @public (undocumented)
export interface Spec {
    chartType: ChartType;
    id: string;
    specType: string;
}

// @public (undocumented)
export type SpecId = string;

// @public (undocumented)
export const SpecType: Readonly<{
    Series: "series";
    Axis: "axis";
    Annotation: "annotation";
    Settings: "settings";
    IndexOrder: "index_order";
    SmallMultiples: "small_multiples";
}>;

// @public (undocumented)
export type SpecType = $Values<typeof SpecType>;

// @public
export const StackMode: Readonly<{
    Percentage: "percentage";
    Wiggle: "wiggle";
    Silhouette: "silhouette";
}>;

// @public
export type StackMode = $Values<typeof StackMode>;

// @public (undocumented)
export interface Statistics {
    // (undocumented)
    globalAggregate: number;
}

// @public (undocumented)
export const STATISTICS_KEY = "statistics";

// @public
export interface StrokeDashArray {
    dash: number[];
}

// @public
export interface StrokeStyle<C = Color> {
    stroke: C;
    strokeWidth: number;
}

// @public
export interface TextAlignment {
    // (undocumented)
    horizontal: HorizontalAlignment;
    // (undocumented)
    vertical: VerticalAlignment;
}

// @public
export interface TextOffset {
    reference: 'global' | 'local';
    x: number | string;
    y: number | string;
}

// @public (undocumented)
export interface TextStyle {
    // (undocumented)
    fill: Color;
    // (undocumented)
    fontFamily: string;
    // (undocumented)
    fontSize: number;
    // (undocumented)
    fontStyle?: FontStyle;
    // (undocumented)
    padding: number | SimplePadding;
}

// @public (undocumented)
export interface TexturedPathStyles extends TexturedStylesBase {
    path: string | Path2D;
}

// @public (undocumented)
export interface TexturedShapeStyles extends TexturedStylesBase {
    shape: TextureShape;
}

// @public
export type TexturedStyles = TexturedPathStyles | TexturedShapeStyles;

// @public (undocumented)
export interface TexturedStylesBase {
    dash?: number[];
    fill?: Color | ColorVariant;
    offset?: Partial<Point> & {
        global?: boolean;
    };
    opacity?: number;
    rotation?: number;
    shapeRotation?: number;
    size?: number;
    // Warning: (ae-forgotten-export) The symbol "Point" needs to be exported by the entry point index.d.ts
    spacing?: Partial<Point> | number;
    stroke?: Color | ColorVariant;
    strokeWidth?: number;
}

// @public (undocumented)
export const TextureShape: Readonly<{
    Line: "line";
    Circle: "circle";
    Square: "square";
    Diamond: "diamond";
    Plus: "plus";
    X: "x";
    Triangle: "triangle";
}>;

// @public (undocumented)
export type TextureShape = $Values<typeof TextureShape>;

// @public (undocumented)
export interface Theme {
    // (undocumented)
    arcSeriesStyle: ArcSeriesStyle;
    areaSeriesStyle: AreaSeriesStyle;
    // (undocumented)
    axes: AxisStyle;
    background: BackgroundStyle;
    barSeriesStyle: BarSeriesStyle;
    bubbleSeriesStyle: BubbleSeriesStyle;
    chartMargins: Margins;
    chartPaddings: Margins;
    // (undocumented)
    colors: ColorConfig;
    // (undocumented)
    crosshair: CrosshairStyle;
    // (undocumented)
    goal: GoalStyles;
    // (undocumented)
    legend: LegendStyle;
    lineSeriesStyle: LineSeriesStyle;
    markSizeRatio?: number;
    // (undocumented)
    scales: ScalesConfig;
    // (undocumented)
    sharedStyle: SharedGeometryStateStyle;
}

// @public (undocumented)
export type TickFormatter<V = any> = (value: V, options?: TickFormatterOptions) => string;

// @public (undocumented)
export type TickFormatterOptions = {
    timeZone?: string;
};

// @public (undocumented)
export type TickStyle = StrokeStyle & Visible & {
    padding: number;
    size: number;
};

// @public (undocumented)
export function timeFormatter(format: string): TickFormatter;

// @public
export function toEntries<T extends Record<string, string>, S>(array: T[], accessor: keyof T, staticValue: S): Record<string, S>;

// @public
export interface TooltipInfo {
    header: TooltipValue | null;
    values: TooltipValue[];
}

// @public
export interface TooltipPortalSettings<B = never> {
    boundary?: HTMLElement | B;
    boundaryPadding?: Partial<Padding> | number;
    fallbackPlacements?: Placement[];
    offset?: number;
    placement?: Placement;
}

// @public
export type TooltipProps = TooltipPortalSettings<'chart'> & {
    type?: TooltipType;
    snap?: boolean;
    headerFormatter?: TooltipValueFormatter;
    unit?: string;
    customTooltip?: CustomTooltip;
    stickTo?: TooltipStickTo;
    showNullValues?: boolean;
};

// @public
export type TooltipSettings = TooltipType | TooltipProps;

// @public
export const TooltipStickTo: Readonly<{
    Top: "top";
    Bottom: "bottom";
    Middle: "middle";
    Left: "left";
    Right: "right";
    Center: "center";
    MousePosition: "MousePosition";
}>;

// @public (undocumented)
export type TooltipStickTo = $Values<typeof TooltipStickTo>;

// @public
export const TooltipType: Readonly<{
    VerticalCursor: "vertical";
    Crosshairs: "cross";
    Follow: "follow";
    None: "none";
}>;

// @public
export type TooltipType = $Values<typeof TooltipType>;

// @public
export interface TooltipValue<D extends BaseDatum = Datum> {
    color: Color;
    datum?: D;
    formattedMarkValue?: string | null;
    formattedValue: string;
    isHighlighted: boolean;
    isVisible: boolean;
    label: string;
    markValue?: number | null;
    seriesIdentifier: SeriesIdentifier;
    value: any;
    valueAccessor?: Accessor<D>;
}

// @public
export type TooltipValueFormatter = (data: TooltipValue) => JSX.Element | string;

// @public (undocumented)
export type TreeLevel = number;

// @public (undocumented)
export interface TreeNode extends AngleFromTo {
    // (undocumented)
    fill?: Color;
    // (undocumented)
    x0: Radian;
    // (undocumented)
    x1: Radian;
    // (undocumented)
    y0: TreeLevel;
    // (undocumented)
    y1: TreeLevel;
}

// @public
export interface UnaryAccessorFn<D extends BaseDatum = any, Return = any> {
    // (undocumented)
    (datum: D): Return;
    fieldName?: string;
}

// @public (undocumented)
export type ValueAccessor<D extends BaseDatum = Datum> = (d: D) => AdditiveNumber;

// @public (undocumented)
export type ValueFormatter = (value: number) => string;

// Warning: (ae-forgotten-export) The symbol "ValueGetterName" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type ValueGetter = ValueGetterFunction | ValueGetterName;

// @public (undocumented)
export type ValueGetterFunction = (node: ShapeTreeNode) => number;

// @public (undocumented)
export const VerticalAlignment: Readonly<{
    Middle: "middle";
    Top: "top";
    Bottom: "bottom";
    Near: "near";
    Far: "far";
}>;

// @public
export type VerticalAlignment = $Values<typeof VerticalAlignment>;

// @public (undocumented)
export interface Visible {
    // (undocumented)
    visible: boolean;
}

// @public (undocumented)
export const WeightFn: Readonly<{
    log: "log";
    linear: "linear";
    exponential: "exponential";
    squareRoot: "squareRoot";
}>;

// @public (undocumented)
export type WeightFn = $Values<typeof WeightFn>;

// @alpha
export const Wordcloud: FC<SFProps<WordcloudSpec, "chartType" | "specType", "fontStyle" | "fontWeight" | "fontFamily" | "padding" | "minFontSize" | "maxFontSize" | "data" | "exponent" | "config" | "startAngle" | "endAngle" | "angleCount" | "spiral" | "weightFn" | "outOfRoomCallback", never, "id">>;

// @public (undocumented)
export interface WordcloudConfigs {
    // (undocumented)
    count: number;
    // (undocumented)
    endAngle: number;
    // (undocumented)
    exponent: number;
    // (undocumented)
    fontFamily: string;
    // (undocumented)
    fontStyle: FontStyle;
    // (undocumented)
    fontWeight: number;
    // (undocumented)
    height: number;
    // (undocumented)
    maxFontSize: number;
    // (undocumented)
    minFontSize: number;
    // (undocumented)
    padding: number;
    // (undocumented)
    spiral: string;
    // (undocumented)
    startAngle: number;
    // (undocumented)
    weightFn: WeightFn;
    // (undocumented)
    width: number;
}

// @public (undocumented)
export type WordCloudElementEvent = [WordModel, SeriesIdentifier];

// Warning: (ae-incompatible-release-tags) The symbol "WordcloudProps" is marked as @public, but its signature references "Wordcloud" which is marked as @alpha
//
// @public (undocumented)
export type WordcloudProps = ComponentProps<typeof Wordcloud>;

// @alpha (undocumented)
export interface WordcloudSpec extends Spec {
    // (undocumented)
    angleCount: number;
    // (undocumented)
    chartType: typeof ChartType.Wordcloud;
    // (undocumented)
    config: RecursivePartial<WordcloudConfigs>;
    // (undocumented)
    data: WordModel[];
    // (undocumented)
    endAngle: number;
    // (undocumented)
    exponent: number;
    // (undocumented)
    fontFamily: string;
    // (undocumented)
    fontStyle: FontStyle;
    // (undocumented)
    fontWeight: number;
    // (undocumented)
    maxFontSize: number;
    // (undocumented)
    minFontSize: number;
    // (undocumented)
    outOfRoomCallback: OutOfRoomCallback;
    // (undocumented)
    padding: number;
    // (undocumented)
    specType: typeof SpecType.Series;
    // (undocumented)
    spiral: string;
    // (undocumented)
    startAngle: number;
    // (undocumented)
    weightFn: WeightFn;
}

// @public (undocumented)
export interface WordModel {
    // (undocumented)
    color: Color;
    // (undocumented)
    text: string;
    // (undocumented)
    weight: number;
}

// @public (undocumented)
export type XScaleType = typeof ScaleType.Ordinal | ScaleContinuousType;

// @public (undocumented)
export interface XYBrushEvent {
    // (undocumented)
    x?: [number, number];
    // (undocumented)
    y?: Array<GroupBrushExtent>;
}

// @public (undocumented)
export type XYChartElementEvent = [GeometryValue, XYChartSeriesIdentifier];

// @public (undocumented)
export interface XYChartSeriesIdentifier<D extends BaseDatum = Datum> extends SeriesIdentifier {
    // (undocumented)
    seriesKeys: (string | number)[];
    // (undocumented)
    smHorizontalAccessorValue?: string | number;
    // (undocumented)
    smVerticalAccessorValue?: string | number;
    // (undocumented)
    splitAccessors: Map<string | number, string | number>;
    // (undocumented)
    yAccessor: Accessor<D>;
}

// @public
export interface YDomainBase {
    constrainPadding?: boolean;
    fit?: boolean;
    padding?: number;
    paddingUnit?: DomainPaddingUnit;
}

// @public (undocumented)
export type YDomainRange = YDomainBase & DomainRange & LogScaleOptions;

// Warnings were encountered during analysis:
//
// src/chart_types/heatmap/layout/types/config_types.ts:19:13 - (ae-forgotten-export) The symbol "SizeRatio" needs to be exported by the entry point index.d.ts
// src/chart_types/heatmap/layout/types/config_types.ts:47:5 - (ae-forgotten-export) The symbol "TextAlign" needs to be exported by the entry point index.d.ts
// src/chart_types/heatmap/layout/types/config_types.ts:48:5 - (ae-forgotten-export) The symbol "TextBaseline" needs to be exported by the entry point index.d.ts
// src/chart_types/partition_chart/layout/types/config_types.ts:137:5 - (ae-forgotten-export) The symbol "TimeMs" needs to be exported by the entry point index.d.ts
// src/chart_types/partition_chart/layout/types/config_types.ts:138:5 - (ae-forgotten-export) The symbol "AnimKeyframe" needs to be exported by the entry point index.d.ts

// (No @packageDocumentation comment for this package)

```
